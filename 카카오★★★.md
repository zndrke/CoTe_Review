# 카카오★★★

### 1. 문자 숫자 변환 ★★

###### 문제 설명

![img1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png)

네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.

다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.

- 1478 → "one4seveneight"
- 234567 → "23four5six7"
- 10203 → "1zerotwozero3"

이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 `s`가 매개변수로 주어집니다. `s`가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.

참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.

| 숫자 | 영단어 |
| ---- | ------ |
| 0    | zero   |
| 1    | one    |
| 2    | two    |
| 3    | three  |
| 4    | four   |
| 5    | five   |
| 6    | six    |
| 7    | seven  |
| 8    | eight  |
| 9    | nine   |

------

##### 제한사항

- 1 ≤ `s`의 길이 ≤ 50
- `s`가 "zero" 또는 "0"으로 시작하는 경우는 주어지지 않습니다.
- return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 `s`로 주어집니다.

------

##### 입출력 예

| s                    | result |
| -------------------- | ------ |
| `"one4seveneight"`   | 1478   |
| `"23four5six7"`      | 234567 |
| `"2three45sixseven"` | 234567 |
| `"123"`              | 123    |

------

##### 입출력 예 설명

**입출력 예 #1**

- 문제 예시와 같습니다.

**입출력 예 #2**

- 문제 예시와 같습니다.

**입출력 예 #3**

- "three"는 3, "six"는 6, "seven"은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다.
- 입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.

**입출력 예 #4**

- `s`에는 영단어로 바뀐 부분이 없습니다.



### 코드 

~~~java
import java.util.*;
class Solution {
    public int solution(String s) {
        int answer = 0;
        String result = "";
        String[] numbers = {"zero","one","two","three","four","five","six","seven","eight","nine"};
        
        for (int i = 0; i < s.length(); i++) {
            //숫자가 아니면 
            if (!Character.isDigit(s.charAt(i))) {
                for (int j = 0; j < numbers.length; j++) {
                    //numbers와 일치하는 값으로 
                    int len = numbers[j].length();
                    if ( s.length() > i + 2){
                        if (numbers[j].substring(0,2).equals(s.substring(i, i + 2))) {
                            result += String.valueOf(j);
                            if (s.length() >= i + len - 1){
                                break;
                            }
                            i = i + len - 1 ;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                result += s.charAt(i);
            }
        }
        answer = Integer.parseInt(result);
        return answer;
    }
}
~~~

- i를 임의로 다룰때는 범위를 벗어나는지 잘 검사해야 한다
- 알파벳의 길이가 다 달라서 무엇을 기준으로 비교할지 고민했다. 숫자의 알파벳은 모두 세자리 이상 있고, 앞의 두자리가 같은 것은 없으므로 알파벳 두개를 비교해서 일치하는 숫자를 만들었다



### 2. 테이블 띄우기 ★★

###### 문제 설명

개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.

코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼
아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.

> 1. 대기실은 5개이며, 각 대기실은 5x5 크기입니다.
> 2. 거리두기를 위하여 응시자들 끼리는 맨해튼 거리[1](https://programmers.co.kr/tryouts/23568/challenges#fn1)가 2 이하로 앉지 말아 주세요.
> 3. 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.

예를 들어,

| ![PXP.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8c056cac-ec8f-435c-a49a-8125df055c5e/PXP.png) | ![PX_XP.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d611f66e-f9c4-4433-91ce-02887657fe7f/PX_XP.png) | ![PX_OP.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ed707158-0511-457b-9e1a-7dbf34a776a5/PX_OP.png) |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 **지킨 것입니다.** | 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 **지킨 것입니다.** | 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 **지키지 않은 것입니다.** |
| ![P.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4c548421-1c32-4947-af9e-a45c61501bc4/P.png) | ![O.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ce799a38-668a-4038-b32f-c515b8701262/O.png) | ![X.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/91e8f98b-baeb-4f81-8cb6-5bafebebdcc7/X.png) |
|          응시자가 앉아있는 자리(`P`)를 의미합니다.           |                 빈 테이블(`O`)을 의미합니다.                 |                  파티션(`X`)을 의미합니다.                   |

5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 `places`가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

------

##### 제한사항

- ```
  places
  ```

  의 행 길이(대기실 개수) = 5

  - `places`의 각 행은 하나의 대기실 구조를 나타냅니다.

- `places`의 열 길이(대기실 세로 길이) = 5

- ```
  places
  ```

  의 원소는

   

  ```
  P
  ```

  ,

  ```
  O
  ```

  ,

  ```
  X
  ```

  로 이루어진 문자열입니다.

  - `places` 원소의 길이(대기실 가로 길이) = 5
  - `P`는 응시자가 앉아있는 자리를 의미합니다.
  - `O`는 빈 테이블을 의미합니다.
  - `X`는 파티션을 의미합니다.

- 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다.

- return 값 형식

  - 1차원 정수 배열에 5개의 원소를 담아서 return 합니다.
  - `places`에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다.
  - 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.

------

##### 입출력 예

| places                                                       | result          |
| ------------------------------------------------------------ | --------------- |
| `[["POOOP", "OXXOX", "OPXPX", "OOXOX", "POXXP"], ["POOPX", "OXPXP", "PXXXO", "OXXXO", "OOOPP"], ["PXOPX", "OXOXP", "OXPXX", "OXXXP", "POOXX"], ["OOOXX", "XOOOX", "OOOXX", "OXOOX", "OOOOO"], ["PXPXP", "XPXPX", "PXPXP", "XPXPX", "PXPXP"]]` | [1, 0, 1, 1, 1] |

------

##### 입출력 예 설명

**입출력 예 #1**

첫 번째 대기실

|      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| No.  | 0    | 1    | 2    | 3    | 4    |
| 0    | P    | O    | O    | O    | P    |
| 1    | O    | X    | X    | O    | X    |
| 2    | O    | P    | X    | P    | X    |
| 3    | O    | O    | X    | O    | X    |
| 4    | P    | O    | X    | X    | P    |

- 모든 응시자가 거리두기를 지키고 있습니다.

두 번째 대기실

|      |       |      |       |       |       |
| ---- | ----- | ---- | ----- | ----- | ----- |
| No.  | 0     | 1    | 2     | 3     | 4     |
| 0    | **P** | O    | O     | **P** | X     |
| 1    | O     | X    | **P** | X     | P     |
| 2    | **P** | X    | X     | X     | O     |
| 3    | O     | X    | X     | X     | O     |
| 4    | O     | O    | O     | **P** | **P** |

- (0, 0) 자리의 응시자와 (2, 0) 자리의 응시자가 거리두기를 지키고 있지 않습니다.
- (1, 2) 자리의 응시자와 (0, 3) 자리의 응시자가 거리두기를 지키고 있지 않습니다.
- (4, 3) 자리의 응시자와 (4, 4) 자리의 응시자가 거리두기를 지키고 있지 않습니다.

세 번째 대기실

|      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| No.  | 0    | 1    | 2    | 3    | 4    |
| 0    | P    | X    | O    | P    | X    |
| 1    | O    | X    | O    | X    | P    |
| 2    | O    | X    | P    | X    | X    |
| 3    | O    | X    | X    | X    | P    |
| 4    | P    | O    | O    | X    | X    |

- 모든 응시자가 거리두기를 지키고 있습니다.

네 번째 대기실

|      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| No.  | 0    | 1    | 2    | 3    | 4    |
| 0    | O    | O    | O    | X    | X    |
| 1    | X    | O    | O    | O    | X    |
| 2    | O    | O    | O    | X    | X    |
| 3    | O    | X    | O    | O    | X    |
| 4    | O    | O    | O    | O    | O    |

- 대기실에 응시자가 없으므로 거리두기를 지키고 있습니다.

다섯 번째 대기실

|      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| No.  | 0    | 1    | 2    | 3    | 4    |
| 0    | P    | X    | P    | X    | P    |
| 1    | X    | P    | X    | P    | X    |
| 2    | P    | X    | P    | X    | P    |
| 3    | X    | P    | X    | P    | X    |
| 4    | P    | X    | P    | X    | P    |

- 모든 응시자가 거리두기를 지키고 있습니다.

두 번째 대기실을 제외한 모든 대기실에서 거리두기가 지켜지고 있으므로, 배열 [1, 0, 1, 1, 1]을 return 합니다.





### 3. 방향키와 삭제, 리셋 명령어 ★★

###### 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다

![table_1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d8e89054-53ba-4222-a485-dc56893f45e4/table_1.png)

위 그림에서 파란색으로 칠해진 칸은 현재 **선택된 행**을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.

- `"U X"`: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.
- `"D X"`: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.
- `"C"` : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.
- `"Z"` : 가장 최근에 삭제된 행을 원래대로 복구합니다. **단, 현재 선택된 행은 바뀌지 않습니다.**

예를 들어 위 표에서 `"D 2"`를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, `"C"`를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 "네오"가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다).

![table_2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/453bbb71-df69-4be2-a223-67361878202c/table_2.png)

다음으로 `"U 3"`을 수행한 다음 `"C"`를 수행한 후의 표 상태는 아래 그림과 같습니다.

![table_3.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/61261fa2-701d-4db5-9aa2-a56dd85a3dbf/table_3.png)

다음으로 `"D 4"`를 수행한 다음 `"C"`를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다.

![table_4.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b1a63278-be97-4e3a-a653-5a6aa0f477ba/table_4.png)

다음으로 `"U 2"`를 수행하면 현재 선택된 행은 2행이 됩니다.

![table_5.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b1189eff-e4ee-4119-bb55-a1f06e388c29/table_5.png)

위 상태에서 `"Z"`를 수행할 경우 가장 최근에 제거된 `"라이언"`이 적힌 행이 원래대로 복구됩니다.

![table_6.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0a386d19-0391-46a7-8086-9f36db31940d/table_6.png)

다시한번 `"Z"`를 수행하면 그 다음으로 최근에 제거된 `"콘"`이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요.
![table_7.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8900360f-bf0b-449b-a508-98918a14ef1d/table_7.png)

이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 `"O"`, 삭제된 행은 `"X"`로 표시하면 다음과 같습니다.

![table_8.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/87a31aeb-50fb-4c0d-9f6b-8427632b582e/table_8.png)

처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 5 ≤ `n` ≤ 1,000,000

- 0 ≤ `k` < `n`

- 1 ≤

   

  ```
  cmd
  ```

  의 원소 개수 ≤ 200,000

  - `cmd`의 각 원소는 `"U X"`, `"D X"`, `"C"`, `"Z"` 중 하나입니다.
  - X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.
  - X가 나타내는 자연수에 ',' 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.
  - `cmd`에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.
  - 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.
  - 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 `"이름"` 열을 사용하였으나, `"이름"`열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. `"이름"`열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.

- 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.

- 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) "Z"가 명령어로 주어지는 경우는 없습니다.

- 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.

##### 정확성 테스트 케이스 제한 사항

- 5 ≤ `n` ≤ 1,000
- 1 ≤ `cmd`의 원소 개수 ≤ 1,000

##### 효율성 테스트 케이스 제한 사항

- 주어진 조건 외 추가 제한사항 없습니다.

------

##### 입출력 예

| n    | k    | cmd                                                       | result       |
| ---- | ---- | --------------------------------------------------------- | ------------ |
| 8    | 2    | `["D 2","C","U 3","C","D 4","C","U 2","Z","Z"]`           | `"OOOOXOOO"` |
| 8    | 2    | `["D 2","C","U 3","C","D 4","C","U 2","Z","Z","U 1","C"]` | `"OOXOXOOO"` |

------

##### 입출력 예 설명

**입출력 예 #1**

문제의 예시와 같습니다.

**입출력 예 #2**

다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다.

![table_7.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8900360f-bf0b-449b-a508-98918a14ef1d/table_7.png)

10번째 명령어 `"U 1"`을 수행하면 `"어피치"`가 적힌 2행이 선택되며, 마지막 명령어 `"C"`를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 `"제이지"`가 적힌 행을 선택합니다.

![table_9.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/c9798574-4aa9-4029-901f-21f83fe43164/table_9.png)

따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다.

![table_10.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e7ba17b2-9461-4e92-8356-81cc90adb2ec/table_10.png)



### 코드

~~~java
import java.util.*;
class Solution {
    int lastOne(boolean[] check) {
        int i = check.length - 1;
        while(check[i] != false){
            i--;
        }
        return i;
    }
    public String solution(int n, int k, String[] cmd) {
        String answer = "";
        boolean[] check = new boolean[n];
        Stack<Integer> stack = new Stack<>();
        
        for (int i = 0; i < cmd.length; i++) {
            System.out.println(k);
            if(cmd[i].charAt(0) == 'U'){
                int deleted = 0;
                int order_num = Integer.parseInt(cmd[i].substring(2,cmd[i].length()));
                for (int j = k - order_num; j < k ; j++) {
                    if(check[j] == true) {
                        deleted++;
                    }
                }
                k = k - deleted - order_num ; 
            }
            else if(cmd[i].charAt(0) == 'D') {
                int deleted = 0;
                int order_num = Integer.parseInt(cmd[i].substring(2,cmd[i].length()));
                for ( int j = k; j <= k + order_num ; j++) {
                    if( check[j] == true) {
                        deleted++;
                    }
                }
                k = k + deleted + order_num; 
            }
            else if(cmd[i].charAt(0) == 'C') {
                //마지막이면
                if (lastOne(check) == k) {
                    check[k] = true;
                    stack.push(k);
                    k--;
                }
                else {
                    check[k] = true;
                    stack.push(k);
                    k++;
                }
            }
            else if(cmd[i].charAt(0) == 'Z') {
                check[stack.pop()] = false;
            }
        }
        for ( int i = 0; i < n ; i++) {
            if( check[i] == true) {
                answer += 'X';
            }
            else {
                answer += 'O';
            }
        }
        return answer;
    }
}
~~~

- 반정도는 성공하고 나머지는 런타임에러가 난다. 
- 효율성에서 떨어지는 듯
-  n이 최대 1,000,000 개이므로 마지막을 찾는 lastOne 메소드가 부담이 되는 것 같다



### 4. 트랩을 지나 시작노드에서 끝노드로 가는 최단 비용

###### 문제 설명

신규 게임 ‘카카오 미로 탈출’이 출시되어, `라이언`이 베타테스터로 참가했습니다.

![Maze.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0015adcc-d76e-40e3-8004-70dd8deff2ec/Maze.png)

위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정에 걸리면 함정과 연결된 모든 화살표의 방향이 바뀝니다.
출발지점인 `1`번 방에서 탈출이 가능한 `3`번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다.

- 그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다.

  - 방이 `n`개일 때, 방 번호는 1부터 `n`까지 사용됩니다.

- 화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다.

  - 화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다.

- 그림에 표시된 빨간색 방인

   

  ```
  2
  ```

  번 방은 함정입니다.

  - 함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다.
  - 위 그림 `1`번 방에서 `2`번 방으로 이동하는 순간 `1`에서 `2`로 이동할 수 있던 길은 `2`에서 `1`로 이동할 수 있는 길로 바뀌고, `3`에서 `2`로 이동할 수 있던 길은 `2`에서 `3`으로 이동할 수 있는 길로 바뀝니다.
  - 똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다.

- 미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다.

  - 1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다.
  - 함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다.
  - 2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다.
  - 탈출에 성공했습니다. 총 이동시간은 5입니다.

방의 개수를 나타내는 정수 `n`, 출발 방의 번호 `start`, 도착 방의 번호 `end`, 통로와 이동시간을 나타내는 2차원 정수 배열 `roads`, 함정 방의 번호를 담은 정수 배열 `traps`이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 1 ≤ `n` ≤ 1,000

- 1 ≤ `start` ≤ `n`

- 1 ≤ `end` ≤ `n`

- 1 ≤ `roads`의 행 길이 ≤ 3,000

- ```
  roads
  ```

  의 행은 [P, Q, S]로 이루어져 있습니다.

  - `P`에서 `Q`로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 `S`만큼 시간이 걸립니다.
  - 1 ≤ `P` ≤ `n`
  - 1 ≤ `Q` ≤ `n`
  - `P` ≠ `Q`
  - 1 ≤ `S` ≤ 3,000
  - 서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다.

- 0 ≤

   

  ```
  traps
  ```

  의 길이 ≤ 10

  - 1 ≤ `traps`의 원소 ≤ `n`
  - 시작 방과 도착 방은 함정이 아닙니다.

- 항상 미로를 탈출할 수 있는 경우만 주어집니다.

------

##### 입출력 예

| n    | start | end  | roads                             | traps  | result |
| ---- | ----- | ---- | --------------------------------- | ------ | ------ |
| 3    | 1     | 3    | [[1, 2, 2], [3, 2, 3]]            | [2]    | 5      |
| 4    | 1     | 4    | [[1, 2, 1], [3, 2, 1], [2, 4, 1]] | [2, 3] | 4      |

------

##### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

![MazeEx2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/c5ab2e6d-9872-42d1-9898-2890b69ce74e/MazeEx2.png)

1 → 2 → 3 → 2 → 4 순서로 이동하면 됩니다. 총 이동시간은 4입니다.





### 5. 최대 그룹이 가장 적은 비용이 되는 이진 트리

###### 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

카카오 인턴을 선발하는 코딩 테스트 시험장이 하나의 이진 트리[1](https://programmers.co.kr/tryouts/23568/challenges#fn1) 형태로 연결되어 있습니다. 아래 그림은 12개의 시험장이 연결된 예시입니다.

![img1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/cf7517dd-e241-4fc8-a134-1d4d31f082b2/img1.png)

1. 하나의 노드는 하나의 시험장을 나타냅니다.

2. 검은 바탕의 흰 숫자는 해당 시험장의 고유 번호(ID)를 나타냅니다.

   2-1. 시험장이 n개 있다면, 시험장의 고유 번호는 0부터 n-1까지 부여됩니다.

3. 노드 안의 빨간 숫자는, 해당 시험장의 응시자 수를 나타냅니다.

   3-1. 위의 그림에서, 9번 시험장에는 10명, 4번 시험장에는 8명, 6번 시험장에는 20명의 응시자가 시험을 볼 예정입니다.

4. 노드 사이의 간선은 해당 시험장이 연결되어 있음을 의미합니다.

   4-1. 위의 그림에서, 9번 시험장은 7번 시험장과, 7번 시험장은 6번 시험장과 연결되어 있습니다.

코딩 테스트를 총괄하는 무지는 안정적인 시험을 위해, 시험장에서 오는 트래픽을 `k`개의 그룹으로 나누어 각 그룹별 서버로 분산시키기로 하였습니다. 시험장 사이를 연결한 간선들 중 `k-1`개를 끊어서 시험장을 `k` 개의 그룹으로 나눌 계획입니다. 이때, 그룹별 최대 트래픽을 최소화하기 위하여 **가장 큰 그룹의 인원을 최소화시켜야 합니다.**

![img2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/736fc6c6-0ec5-429b-99b4-304233bc19ff/img2.png)

위의 그림에서 7번과 6번 시험장을 잇는 간선을 끊고, 9번과 7번 시험장을 잇는 간선을 끊는다면, 전체 시험장은 3개의 그룹으로 나누어집니다.

- 주황색 노드로 표시된 A그룹의 인원은 35명(10+8+5+6+1+1+4)
- 보라색 노드로 표시된 B그룹의 인원은 37명(7+30)
- 녹색 노드로 표시된 C그룹의 인원은 40명(20+8+12)

즉, 인원이 가장 많은 그룹은 40명입니다. 다른 어떤 방법으로 시험장을 3개의 그룹으로 나눈다고 해도, 인원이 가장 많은 그룹의 인원이 40명 미만이 되도록 나눌 수는 없습니다.

나눌 그룹의 수를 나타내는 정수 `k`, 각 시험장의 응시자 수를 나타내는 1차원 정수 배열 `num`, 시험장의 연결 상태를 나타내는 2차원 정수 배열 `links`가 매개변수로 주어집니다. 인원이 가장 많은 그룹의 인원이 최소화되도록 `k`개의 그룹으로 나누었을 때, 최소화된 최대 그룹의 인원을 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 1 ≤ `k` ≤ 10,000

- ```
  k
  ```

   

  ≤

   

  ```
  num
  ```

  의 길이 ≤ 10,000

  - `num[i]`에는 i번 시험장의 응시자 수가 담겨있습니다.
  - 1 ≤ `num`의 원소 ≤ 10,000

- ```
  links
  ```

  의 길이 =

   

  ```
  num
  ```

  의 길이

  - ```
    links
    ```

    의 i번째 행은 i번 노드(시험장)의 [왼쪽 자식 노드 번호, 오른쪽 자식 노드 번호]입니다.

    - 해당 위치에 자식 노드가 없는 경우 `-1`이 담겨있습니다.
    - 잘못된 노드 번호나, 하나의 이진 트리 구조가 아닌 입력은 주어지지 않습니다.

##### 정확성 테스트 케이스 제한 사항

- 1 ≤ `k` ≤ 20
- `k` ≤ `num`의 길이 ≤ 20

##### 효율성 테스트 케이스 제한 사항

- 주어진 조건 외 추가 제한사항 없습니다.

------

##### 입출력 예

| k    | num                                      | links                                                        | result |
| ---- | ---------------------------------------- | ------------------------------------------------------------ | ------ |
| 3    | [12, 30, 1, 8, 8, 6, 20, 7, 5, 10, 4, 1] | [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 5], [2, 10], [3, 0], [6, 1], [11, -1], [7, 4], [-1, -1], [-1, -1]] | 40     |
| 1    | [6, 9, 7, 5]                             | [[-1, -1], [-1, -1], [-1, 0], [2, 1]]                        | 27     |
| 2    | [6, 9, 7, 5]                             | [[-1, -1], [-1, -1], [-1, 0], [2, 1]]                        | 14     |
| 4    | [6, 9, 7, 5]                             | [[-1, -1], [-1, -1], [-1, 0], [2, 1]]                        | 9      |

------

##### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

![img3.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9accb8ee-00f3-44ad-b788-b1e9eb138d43/img3.png)

- 나눌 그룹의 수가 1개 이므로, 주어진 트리를 나눌 수 없습니다.
- 보라색 노드로 표시된 유일한 그룹의 인원은 27명입니다.

**입출력 예 #3**

![img4.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e212604c-035d-469c-8f37-9b0a4cfdf7b3/img4.png)

- 나눌 그룹의 수가 2개 이므로, 그림과 같이 1개의 간선을 끊어서 2개의 그룹으로 나눌 수 있습니다.
- 보라색 노드로 표시된 그룹은 13명, 주황색 노드로 표시된 그룹은 14명입니다.
- 따라서, 최대 그룹의 인원은 14명입니다.

**입출력 예 #4**

![img5.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d4a11541-e66b-4beb-a60a-fadcca3ca1d0/img5.png)

- 나늘 그룹의 수가 4개 이므로, 그림과 같이 3개의 모든 간선을 끊어서 4개의 그룹으로 나눌 수 있습니다.
- 최대 그룹의 인원은 9명입니다.