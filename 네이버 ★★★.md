# 네이버 ★★★

### 1. 자신의 최대값을 제외한 평균★★

문제 설명

대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.

|          |             |            |        |        |        |
| -------- | ----------- | ---------- | ------ | ------ | ------ |
| No.      | **0**       | **1**      | **2**  | **3**  | **4**  |
| **0**    | ~~**100**~~ | 90         | 98     | 88     | 65     |
| **1**    | 50          | ~~**45**~~ | 99     | 85     | 77     |
| **2**    | 47          | 88         | **95** | 80     | 67     |
| **3**    | 61          | 57         | 100    | **80** | 65     |
| **4**    | 24          | 90         | 94     | 75     | **65** |
| **평균** | 45.5        | 81.25      | 97.2   | 81.6   | 67.8   |
| **학점** | F           | B          | A      | B      | D      |

위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.

- 0번 학생이 평가한 점수는 0번

   

  ```
  행
  ```

  에담긴 [

  100

  , 90, 98, 88, 65]입니다.

  - 0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.

- 2번 학생이 평가한 점수는 2번

   

  ```
  행
  ```

  에담긴 [47, 88,

   

  95

  , 80, 67]입니다.

  - 2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.

당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.
만약, 학생들이 자기 자신을 평가한 점수가 **유일한 최고점** 또는 **유일한 최저점**이라면 그 점수는 제외하고 평균을 구합니다.

- 0번 학생이 받은 점수는 0번

   

  ```
  열
  ```

  에 담긴 [

  ```
  100
  ```

  , 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.

  - 0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.

- 4번 학생이 받은 점수는 4번

   

  ```
  열
  ```

  에 담긴 [65, 77, 67, 65,

   

  ```
  65
  ```

  ]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.

  - 4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.

제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.

| 평균                | 학점 |
| ------------------- | ---- |
| 90점 이상           | A    |
| 80점 이상 90점 미만 | B    |
| 70점 이상 80점 미만 | C    |
| 50점 이상 70점 미만 | D    |
| 50점 미만           | F    |

학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 2 ≤ `scores`의 행의 길이(학생 수) ≤ 10

- ```
  scores
  ```

  의 열의 길이 =

   

  ```
  scores
  ```

  의 행의 길이

  - 즉, `scores`는 행과 열의 길이가 같은 2차원 배열입니다.

- 0 ≤ `scores`의 원소 ≤ 100

- return 값 형식

  - 0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.

------

##### 입출력 예

| scores                                                       | result    |
| ------------------------------------------------------------ | --------- |
| [[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]] | `"FBABD"` |
| [[50,90],[50,87]]                                            | `"DA"`    |
| [[70,49,90],[68,50,38],[73,31,100]]                          | `"CFD"`   |

------

##### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

|          |        |            |
| -------- | ------ | ---------- |
| No.      | **0**  | **1**      |
| **0**    | **50** | 90         |
| **1**    | 50     | ~~**87**~~ |
| **평균** | 50     | 90         |
| **학점** | D      | A          |

- 1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.

**입출력 예 #3**

|          |        |            |             |
| -------- | ------ | ---------- | ----------- |
| No.      | **0**  | **1**      | **2**       |
| **0**    | **70** | 49         | 90          |
| **1**    | 68     | ~~**50**~~ | 38          |
| **2**    | 73     | 31         | ~~**100**~~ |
| **평균** | 70.33… | 40         | 64          |
| **학점** | C      | F          | D           |

- 1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.
- 2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.







### 2. 주어진 철자를 규칙에 따라 암호화 ★★



###### 문제 설명

문장에 한 단어의 철자를 순서대로 반복해서 끼워 넣어 암호화하는 방법이 있습니다. 당신은 이 방법을 통해 문장을 암호화하려고 합니다.

예를 들어, 문장 "i love coding"이 주어지고 키워드 "mask"가 주어지면, "**ma**i l**s**ov**k**e c**m**odin**a**g"과 같이 문장을 바꿀 수 있습니다.

키워드의 첫 번째 철자인 'm'은 원래 문장의 첫 글자인 'i'를 건너뛰지 않고 삽입되었고, 두 번째 철자인 'a'도 원래 문장의 글자를 건너뛰지 않고 'i' 앞에 삽입되었습니다. 세 번째 철자인 's'는 원래 문장의 'i l'을 건너뛴 후 삽입되었고, 네 번째 철자인 'k'는 원래 문장의 'ov'를 건너뛴 후 삽입되었습니다. 키워드의 마지막 철자인 'k'까지 삽입했다면 다시 첫 번째 철자부터 반복합니다. 이후, 'm'은 'e c'를 건너뛴 후 삽입되었고, 'a'는 'odin'을 건너뛴 후 삽입되었습니다. 따라서 키워드의 각 철자들이 건너뛴 문장의 글자 수는 [0, 0, 3, 2, 3, 4]입니다. 즉, 문장과 키워드, 건너뛸 글자 수를 나타내는 배열이 주어지면 암호문을 만들 수 있습니다.

복호화를 하는 방법은 단순합니다. 암호화된 문장을 왼쪽부터 한 글자씩 읽어가면서 키워드에 해당하는 철자가 나오면 해당 알파벳을 지우면 됩니다. 이때 암호화된 문장의 길이를 원래 문장의 길이와 맞추기 위해 철자를 삽입한 횟수만큼만 글자를 지웁니다. 위의 암호화 문장 "**ma**i l**s**ov**k**e c**m**odin**a**g"도 이 방법을 통해 원래 문장으로 복원할 수 있습니다.

그러나 복호화가 제대로 되지 않는 경우도 있습니다. 예를 들어 문장 "i love coding"과 키워드 "mode", 건너뛸 글자 수 [0, 10]이 주어지면 암호문 "**m**i love cod**o**ing"을 만들 수 있습니다. 위의 방법대로 복호화하면 m, o를 순서대로 지워, "i lve cod**o**ing"이라는 결과를 얻게 됩니다. 이런 결과가 나온 이유는 삽입된 키워드의 철자 대신 원래 문장의 글자를 지웠기 때문입니다. 이를 해결하기 위해 암호화를 할 때 다음과 같은 규칙을 따릅니다.

- 키워드의 철자를 삽입하기 위해 원래 문장을 건너뛰는 도중, 방금 건너뛴 글자와 이번에 삽입할 키워드의 철자가 같은 경우 건너뛰는 것을 중단하고 그 위치에 키워드의 철자를 삽입합니다.
- 위 예시의 경우, 0번 건너뛴 위치에 'm'을 삽입한 뒤, 다음 철자 'o'를 삽입하기 위해 10번 건너뛰는 도중에 "love"에서 'o'를 발견하고 "lo"뒤에 'o'를 삽입합니다. 따라서 "**m**i lo**o**ve coding"으로 암호화됩니다. 키워드가 "mode"이고 키워드의 철자를 삽입한 횟수가 2이므로 왼쪽에서부터 첫 번째 'm'와 'o'을 지우면 원래 문장을 얻을 수 있습니다.

암호화하려는 문장을 나타내는 문자열 `sentence`, 키워드를 나타내는 문자열 `keyword`, 건너뛸 글자(또는 공백) 수를 순서대로 나타내는 정수 배열 `skips`가 매개변수로 주어집니다. 위 방법을 따라 만든 암호문을 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 10 ≤ `sentence`의 길이 ≤ 1,000,000

- 2 ≤ `keyword`의 길이 ≤ 20

- 1 ≤

   

  ```
  skips
  ```

  의 길이 ≤ 1,000,000

  - 0 ≤ `skips`의 원소 ≤ 10

- `sentence`는 알파벳 소문자와 공백으로 이루어져 있습니다.

- `sentence`는 공백으로 시작하거나 끝나지 않습니다.

- `keyword`는 알파벳 소문자로 이루어져 있습니다.

- `keyword`에서 같은 알파벳이 연속해서 등장하거나, 첫 알파벳과 마지막 알파벳이 같은 경우는 없습니다.

- `sentence`에서 건너뛴 글자 수가 원래 `sentence`의 길이를 초과하면 즉시 결과를 반환합니다. 다시 말해, 더 이상 건너뛸 글자가 없다면 암호화를 종료합니다.

------

##### 입출력 예

| sentence                  | keyword       | skips                                   | result                                 |
| ------------------------- | ------------- | --------------------------------------- | -------------------------------------- |
| `"i love coding"`         | `"mask"`      | [0, 0, 3, 2, 3, 4]                      | `"mai lsovke cmodinag"`                |
| `"i love coding"`         | `"mode"`      | [0, 10]                                 | `"mi loove coding"`                    |
| `"abcde fghi"`            | `"xyz"`       | [10, 0, 1]                              | `"abcde fghixy"`                       |
| `"encrypt this sentence"` | `"something"` | [0, 1, 3, 2, 1, 2, 0, 3, 0, 2, 4, 1, 3] | `"seoncrmypett thihisng ssenteonmcee"` |

------

##### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

문제 예시와 같습니다.

**입출력 예 #3**

- skips[0]: `sentence`를 왼쪽에서부터 10번 건너뛰고 "fghi"뒤에 'x'를 삽입합니다.
- skips[1]: `sentence`에서 건너뛴 글자 수가 원래 `sentence`의 길이(=10)를 아직 넘지 않았으므로 계속해서 진행합니다. 0번 건너뛴 후 'x' 뒤에 'y'를 삽입합니다.
- skips[2]: 더 이상 건너뛸 글자가 없으므로 암호화를 즉시 종료하고 결과를 반환합니다. 따라서 "abcde fghi**xy**"를 return 합니다.

**입출력 예 #4**

결과 문자열에 삽입된 `keyword`의 철자를 대문자로 표기하면 다음과 같습니다.

```
"SeOncrMypEtT tHIhisNG sSenteOnMceE"
```

결과 문자열 오른쪽에서 네 번째에 위치한 'm'을 삽입한 후, 다음 철자인 'e'를 삽입하기 위해 건너뛰는 횟수는 3입니다. 남은 글자가 'ce' 두 글자뿐이지만, 그중 마지막 글자인 'e'가 삽입할 철자와 겹치므로 2번만 건너뛴 후 'e'를 삽입합니다.



### 3. 가치 측정 ★★★

###### 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

미술 작품에 가격을 매기는 일은 쉽지 않습니다. 작품의 가치를 매길 수 있는 정확한 지표가 없기 때문입니다. 그렇기 때문에 사람의 주관이 많이 들어가게 됩니다.

이런 문제를 해결하기 위해 여러 전문가들에게 감정을 맡겨보기로 했습니다. 하지만 전문가도 항상 정당한 값을 매기기는 어렵습니다. 또 의도적으로 높게 혹은 낮게 가격을 매길 수 있습니다. 그래서 다음과 같은 4가지 방법으로 판매가를 결정하려고 합니다. 1번 방법부터 적용시킬 수 있으면 적용시켜서 판매가를 결정하고, 적용시킬 수 없다면 다음 방법으로 차례차례 넘어갑니다.

1. 가장 비싸게 책정한 가격과 가장 싸게 책정한 가격의 차가 `d`원 이하라면, 모두 정당한 가격으로 책정했다고 판단해 전문가들이 제시한 모든 가격의 평균값으로 판매가를 결정합니다.
2. 가장 비싸게 책정한 가격 하나와 가장 싸게 책정한 가격 하나를 제외시킵니다. 나머지 가격 중, 가장 비싸게 책정한 가격과 가장 싸게 책정한 가격의 차가 `d`원 이하라면, 앞서 제외한 두 가격 외에는 모두 정당한 가격이라고 판단해, 두 가격을 제외한 모든 가격의 평균값으로 판매가를 결정합니다.
3. 전문가들이 매긴 모든 가격에서 임의로 k개의 가격을 골랐을 때 가장 비싸게 책정한 가격과 가장 싸게 책정한 가격의 차가 d원 이하라면, 그 k개의 가격이 정당하다고 판단해 그 k개의 평균값을 판매가로 결정합니다. 만약 정당한 가격을 책정한 k개의 가격을 고르는 방법이 여러 개라면, 그중에서 평균값이 가장 낮은 것을 판매가로 결정합니다.
4. 중앙값을 판매가로 결정합니다. 즉, 전문가들이 매긴 모든 가격을 오름차순으로 정렬했을 때, 가운데 위치하는 가격을 판매가로 결정합니다. **가격의 개수가 짝수라면, 가운데 위치하는 두 가격 중에 크지 않은 가격을 판매가로 결정합니다.**

**[주의사항]**: `평균값을 계산할 때 모든 소수점 이하는 버립니다.`

전문가들이 매긴 가격들을 담은 정수 배열 `prices`, 정수 `d`, 정수 `k` 가 주어질 때, 미술 작품의 판매가를 return 하도록 solution함수를 완성해주세요.

------

##### 제한사항

- 3 ≤ `prices`의 길이 ≤ 1,000,000
- 1 ≤ `prices`의 원소 ≤ 2,000
- 0 ≤ `d` ≤ 2,000
- 1 ≤ `k` ≤ `prices`의 길이

------

##### 입출력 예

| prices             | d    | k    | result |
| ------------------ | ---- | ---- | ------ |
| [4, 5, 6, 7, 8]    | 4    | 3    | 6      |
| [4, 5, 6, 7, 8]    | 2    | 1    | 6      |
| [4, 5, 6, 7, 8]    | 1    | 2    | 4      |
| [8, 4, 5, 7, 6]    | 1    | 3    | 6      |
| [1, 8, 1, 8, 1, 8] | 6    | 4    | 1      |

------

##### 입출력 예 설명

**입출력 예 #1**

가장 비싸게 책정된 가격 - 가장 싸게 책정된 가격 = 8 - 4 = 4,
4 ≤ `d` = 4 이기 때문에, 1번 방법에 따라 전체 가격의 평균을 판매가로 결정합니다.

**입출력 예 #2**

가장 비싸게 책정된 가격 - 가장 싸게 책정된 가격 = 8 - 4 = 4
4 > `d` = 2 이기 때문에 1번 방법을 적용시킬 수 없습니다.
2번 방법에 따라 가장 비싸게 책정된 가격과 가장 싸게 책정된 가격을 제외하고, 가격 차를 확인합니다.
[5, 6, 7]에서 가장 비싸게 책정된 가격은 7, 가장 싸게 책정된 가격은 5입니다.
따라서, 가장 비싸게 책정된 가격 - 가장 싸게 책정된 가격 = 7 - 5 = 2
2 ≤ `d` = 2 이기 때문에 [5, 6, 7]의 평균 가격을 판매가로 결정합니다.

**입출력 예 #3**

입출력 예 #2에서 확인할 수 있듯이 1번 방법과 2번 방법을 모두 적용시킬 수 없습니다.
따라서 3번 방법을 적용시켜야 합니다. 전문가들이 매긴 모든 가격에서 k개의 가격을 고르는 방법은 다음과 같습니다.
[4, 5], [4, 6], [4, 7], [4, 8], [5, 6], [5, 7], [5, 8], [6, 7], [6, 8], [7, 8]
이 중,

가장 비싸게 책정된 가격 - 가장 싸게 책정된 가격 ≤ `d` = 1

위 부등식을 만족하는 결과만 나열해 보면 다음과 같습니다.
[4, 5], [5, 6], [6, 7], [7, 8]
이 네 가격 모두 정당하다고 판단하지만, 3번 방법에 따라 평균 가격이 가장 낮은 것을 판매가로 결정합니다. [4, 5]의 평균에서 소수점 이하를 버린 4원을 판매가로 결정합니다.

**입출력 예 #4**

방법 1, 2, 3을 모두 적용시킬 수 없습니다. 따라서 중앙값인 6원을 판매가로 결정합니다.

**입출력 예 #5**

가장 비싸게 책정된 가격 - 가장 싸게 책정된 가격 = 8 - 1 = 7
7 > `d` = 6 이기 때문에, 1번 방법을 적용시킬 수 없습니다.
2번 방법에 따라 가장 비싸게 책정된 가격과 가장 싸게 책정된 가격을 제외하고, 가격 차를 확인합니다.
[1, 8, 1, 8]에서 가장 비싸게 책정된 가격은 8, 가장 싸게 책정된 가격은 1입니다.
따라서 가장 비싸게 책정된 가격 - 가장 싸게 책정된 가격 = 8 - 1 = 7
7 > `d` = 6 이기 때문에, 2번 방법도 적용시킬 수 없습니다.
3번 방법으로도 판매가를 결정하지 못합니다. 따라서 4번 방법을 적용시켜야 합니다.
전문가들이 책정한 모든 가격 [1, 8, 1, 8, 1, 8]을 오름차순으로 정렬하면 [1, 1, 1, 8, 8, 8]입니다. 중앙에 위치한 2개의 가격 [1, 8] 중에서, 크지 않은 값인 1원을 판매가로 결정합니다.



### 4. 조각 맞추기 ★★★

###### 문제 설명

테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.

- 조각은 한 번에 하나씩 채워 넣습니다.
- 조각을 회전시킬 수 있습니다.
- 조각을 뒤집을 수는 없습니다.
- 게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.

다음은 퍼즐 조각을 채우는 예시입니다.

![puzzle_5.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ab4d8aa2-f282-4764-bb46-84d405464b90/puzzle_5.png)

위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다.

이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다.

![puzzle_6.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/70e371ad-4306-412b-b53b-25208e52a513/puzzle_6.png)

- 3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.
- 5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.

다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다.

![puzzle_7.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dadd0bc1-8e38-4689-a480-26afa799a5a3/puzzle_7.png)

최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다.

현재 게임 보드의 상태 `game_board`, 테이블 위에 놓인 퍼즐 조각의 상태 `table`이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 3 ≤ `game_board`의 행 길이 ≤ 50

- ```
  game_board
  ```

  의 각 열 길이 =

   

  ```
  game_board
  ```

  의 행 길이

  - 즉, 게임 보드는 정사각 격자 모양입니다.
  - `game_board`의 모든 원소는 0 또는 1입니다.
  - 0은 빈칸, 1은 이미 채워진 칸을 나타냅니다.
  - 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.

- `table`의 행 길이 = `game_board`의 행 길이

- ```
  table
  ```

  의 각 열 길이 =

   

  ```
  table
  ```

  의 행 길이

  - 즉, 테이블은 `game_board`와 같은 크기의 정사각 격자 모양입니다.
  - `table`의 모든 원소는 0 또는 1입니다.
  - 0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다.
  - 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.

- `game_board`에는 반드시 하나 이상의 빈칸이 있습니다.

- `table`에는 반드시 하나 이상의 블록이 놓여 있습니다.

------

##### 입출력 예

| game_board                                                   | table                                                        | result |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
| [[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]] | [[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]] | 14     |
| [[0,0,0],[1,1,0],[1,1,1]]                                    | [[1,1,1],[1,0,0],[0,0,0]]                                    | 0      |

------

##### 입출력 예 설명

**입출력 예 #1**

입력은 다음과 같은 형태이며, 문제의 예시와 같습니다.

![puzzle_9.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/653b44d8-0fa6-42f8-aa9d-ceca639b0ad4/puzzle_9.png)

**입출력 예 #2**

블록의 회전은 가능하지만, 뒤집을 수는 없습니다.

